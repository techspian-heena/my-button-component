const removeRipple = (ripple) => {
    setTimeout(() => {
        ripple.remove();
    }, 300);
};
export const initRipple = (event, rippleType = 'bounded', obj = {}) => {
    const buttonClick = event;
    const buttonElement = buttonClick.composedPath()[0];
    const buttonWidth = buttonElement.offsetWidth;
    const buttonHeight = buttonElement.offsetHeight;
    const rippleElement = document.createElement('span');
    rippleElement.classList.add('ripple-effect');
    const style = rippleElement.style;
    if (rippleType === 'unbounded') {
        style.top = buttonHeight * 0.5 + 'px';
        style.left = buttonWidth * 0.5 + 'px';
        style.height = buttonHeight + 'px';
        style.width = buttonWidth + 'px';
    }
    else {
        style.top =
            buttonClick.clientY - buttonElement.offsetTop + document.documentElement.scrollTop + 'px';
        style.left =
            buttonClick.clientX - buttonElement.offsetLeft + document.documentElement.scrollLeft + 'px';
        style.height = style.width = buttonWidth * 2 + 'px';
    }
    if (Object.keys(obj).length !== 0) {
        style.height = obj.height;
        style.width = obj.width;
    }
    const floatBtnRippleTop = buttonClick.clientY - buttonElement.offsetTop + 'px';
    const floatBtnRippleLeft = buttonClick.clientX - buttonElement.offsetLeft + 'px';
    style.setProperty('--float-btn-ripple-top', floatBtnRippleTop);
    style.setProperty('--float-btn-ripple-left', floatBtnRippleLeft);
    const container = buttonClick.srcElement.shadowRoot || buttonClick.srcElement;
    container.appendChild(rippleElement);
    removeRipple(rippleElement);
};
