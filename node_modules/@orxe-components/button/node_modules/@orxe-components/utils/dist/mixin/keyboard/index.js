var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { property } from 'lit-element';
const KEY_IDENTIFIER = {
    'U+0008': 'backspace',
    'U+0009': 'tab',
    'U+001B': 'esc',
    'U+0020': 'space',
    'U+007F': 'del',
};
const KEY_CODE = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    27: 'esc',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    46: 'del',
    106: '*',
};
const MODIFIER_KEYS = {
    shift: 'shiftKey',
    ctrl: 'ctrlKey',
    alt: 'altKey',
    meta: 'metaKey',
};
const KEY_CHAR = /[a-z0-9*]/;
const IDENT_CHAR = /U\+/;
const ARROW_KEY = /^arrow/;
const SPACE_KEY = /^space(bar)?/;
const ESC_KEY = /^escape$/;
function transformKey(key, noSpecialChars) {
    let validKey = '';
    if (key) {
        const lKey = key.toLowerCase();
        if (lKey === ' ' || SPACE_KEY.test(lKey)) {
            validKey = 'space';
        }
        else if (ESC_KEY.test(lKey)) {
            validKey = 'esc';
        }
        else if (lKey.length == 1) {
            if (!noSpecialChars || KEY_CHAR.test(lKey)) {
                validKey = lKey;
            }
        }
        else if (ARROW_KEY.test(lKey)) {
            validKey = lKey.replace('arrow', '');
        }
        else if (lKey == 'multiply') {
            validKey = '*';
        }
        else {
            validKey = lKey;
        }
    }
    return validKey;
}
function transformKeyIdentifier(keyIdent) {
    let validKey = '';
    if (keyIdent) {
        if (keyIdent in KEY_IDENTIFIER) {
            validKey = KEY_IDENTIFIER[keyIdent];
        }
        else if (IDENT_CHAR.test(keyIdent)) {
            keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
            validKey = String.fromCharCode(keyIdent).toLowerCase();
        }
        else {
            validKey = keyIdent.toLowerCase();
        }
    }
    return validKey;
}
function transformKeyCode(keyCode) {
    let validKey = '';
    if (Number(keyCode)) {
        if (keyCode >= 65 && keyCode <= 90) {
            validKey = String.fromCharCode(32 + keyCode);
        }
        else if (keyCode >= 112 && keyCode <= 123) {
            validKey = 'f' + (keyCode - 112 + 1);
        }
        else if (keyCode >= 48 && keyCode <= 57) {
            validKey = String(keyCode - 48);
        }
        else if (keyCode >= 96 && keyCode <= 105) {
            validKey = String(keyCode - 96);
        }
        else {
            validKey = KEY_CODE[keyCode];
        }
    }
    return validKey;
}
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
    if (keyEvent.key) {
        return transformKey(keyEvent.key, noSpecialChars);
    }
    if (keyEvent.detail && keyEvent.detail.key) {
        return transformKey(keyEvent.detail.key, noSpecialChars);
    }
    return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
}
function keyComboMatchesEvent(keyCombo, event) {
    const keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
    return (keyEvent === keyCombo.key &&
        (!keyCombo.hasModifiers ||
            (!!event.shiftKey === !!keyCombo.shiftKey &&
                !!event.ctrlKey === !!keyCombo.ctrlKey &&
                !!event.altKey === !!keyCombo.altKey &&
                !!event.metaKey === !!keyCombo.metaKey)));
}
function parseKeyComboString(keyComboString) {
    if (keyComboString.length === 1) {
        return { combo: keyComboString, key: keyComboString, event: 'keydown' };
    }
    return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
        const eventParts = keyComboPart.split(':');
        const keyName = eventParts[0];
        const event = eventParts[1];
        if (keyName in MODIFIER_KEYS) {
            parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
            parsedKeyCombo.hasModifiers = true;
        }
        else {
            parsedKeyCombo.key = keyName;
            parsedKeyCombo.event = event || 'keydown';
        }
        return parsedKeyCombo;
    }, { combo: keyComboString.split(':').shift() });
}
function parseEventString(eventString) {
    return eventString
        .trim()
        .split(' ')
        .map(function (keyComboString) {
        return parseKeyComboString(keyComboString);
    });
}
export default function (Base) {
    class KeyboardBehaviour extends Base {
        constructor(...args) {
            super(args);
            this._keyBindings = [];
            this.keyEventTarget = this;
            this.stopKeyboardEventPropagation = false;
            this._boundKeyHandlers = [];
            this._prepKeyBindings();
        }
        connectedCallback() {
            super.connectedCallback();
            this._listenKeyEventListeners();
        }
        disconnectedCallback() {
            this._unlistenKeyEventListeners();
        }
        _prepKeyBindings() {
            this._keyBindings = {};
            for (const eventString in this.keyBindings) {
                this._addKeyBinding(eventString, this.keyBindings[eventString]);
            }
            for (const eventName in this._keyBindings) {
                this._keyBindings[eventName].sort(function (kb1, kb2) {
                    const b1 = kb1[0].hasModifiers;
                    const b2 = kb2[0].hasModifiers;
                    return b1 === b2 ? 0 : b1 ? -1 : 1;
                });
            }
        }
        _addKeyBinding(eventString, handlerName) {
            parseEventString(eventString).forEach((keyCombo) => {
                this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];
                this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
            }, this);
        }
        _listenKeyEventListeners() {
            if (!this.keyEventTarget) {
                return;
            }
            Object.keys(this._keyBindings).forEach((eventName) => {
                const keyBindings = this._keyBindings[eventName];
                const boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);
                this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);
                this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
            }, this);
        }
        _unlistenKeyEventListeners() {
            let keyHandlerTuple;
            let keyEventTarget;
            let eventName;
            let boundKeyHandler;
            while (this._boundKeyHandlers.length) {
                keyHandlerTuple = this._boundKeyHandlers.pop();
                keyEventTarget = keyHandlerTuple[0];
                eventName = keyHandlerTuple[1];
                boundKeyHandler = keyHandlerTuple[2];
                keyEventTarget.removeEventListener(eventName, boundKeyHandler);
            }
        }
        _onKeyBindingEvent(keyBindings, event) {
            if (this.stopKeyboardEventPropagation) {
                event.stopPropagation();
            }
            if (event.defaultPrevented) {
                return;
            }
            for (let i = 0; i < keyBindings.length; i++) {
                const keyCombo = keyBindings[i][0];
                const handlerName = keyBindings[i][1];
                if (keyComboMatchesEvent(keyCombo, event)) {
                    this._triggerKeyHandler(keyCombo, handlerName, event);
                    if (event.defaultPrevented) {
                        return;
                    }
                }
            }
        }
        _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
            const detail = Object.create(keyCombo);
            detail.keyboardEvent = keyboardEvent;
            const event = new CustomEvent(keyCombo.event, {
                detail: detail,
                cancelable: true,
            });
            this[handlerName].call(this, event);
            if (event.defaultPrevented) {
                keyboardEvent.preventDefault();
            }
        }
    }
    __decorate([
        property({
            type: Boolean,
            reflect: true,
            attribute: 'stop-keyboard-event-propagation',
        }),
        __metadata("design:type", Object)
    ], KeyboardBehaviour.prototype, "stopKeyboardEventPropagation", void 0);
    return KeyboardBehaviour;
}
